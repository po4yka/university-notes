Оценка алгоритмов

# Оценка алгоритмов

Существует два типа оценки:

1. По времени. Какое количество операций необходимо выполнить алгоритму, чтобы получить нужный результат?

2. По памяти. Какое количество дополнительной памяти требуется алгоритму, чтобы получить требуемый результат?

> с. 501 страница [методички Рыбин-Поздняков](https://docs.google.com/viewer?a=v&pid=sites&srcid=ZGVmYXVsdGRvbWFpbnxzbnBvemRuaWFrb3Z8Z3g6MzdhZTBmMjc1ZWI1Zjc2Zg)

$n$ - входные данные

$T(n)$ - время работы алгоритма

## Оценка сверху

Используется некоторая оценка (сравнение с функцией):

$$
T(n) \le \alpha g(n), n > n_0
$$

Редко удаётся точно найти функцию, задающую сложность алгоритма:

$$
T(n) = O(g(n))
$$

## Классы вычислительной сложности

### Хорошие случаи

1. $T(n) = O(1)$ - не зависит от объёма данных. Например, вычислить первый элемент массива.
2. $T(n) = O(\log(n))$ - растёт очень медленно. Характерно для случаев, когда задачу разбивают на "кусочки". Например, быстрое возведение в степень.
3. $T(n) = O(n^k), k \le 6$ - полиноминальная сложность. В большинстве случаев $k$ не превосходит 6, иначе уже плохо.

### Плохие случаи 

4. $T(n) = O(2^n)$ - экспоненциальная сложность.
5. $T(n) = O(n!)$ - факториальная сложность.

## Оценка сложности

### На основе оценки

Допустим, у нас есть алгоритм  со сложностью работы: $1.7^n$. Работает за $n_0$.

Мы купили новый компьютер, который решает задачу за $n_0 + 4$, $1.7^4 \approx 10$.

А если мы улучшим алгоритм: $1.3^n$, тогда $1.3^2 \approx 1.7$. Получили улучшение $2n_0$.

### На основе класса сложности

1. Класс полиноминальных задач $P$
2. Класс полиноминально-проверяемых задач $NP$ - задачу можно НЕ решить, а проверить за полиноминальное время.

> Задача полноты: $NP = P?$

3. Класс $NP$ полных задач $NPC$ (c - compleate) - задача полиноминально проверяема И все задачи из класса полиноминальных задач можно свести к ней за полиноминальное время.

Примеры последнего типа: построение гамильтонового графа, задача коммивояжера.