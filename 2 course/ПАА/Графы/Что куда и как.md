# Применения алгоритмов на графах

**Алгоритм Тарьяна** - _топологическая сортировка_ нумерацией шагов обхода.

Идея: топологическую сортировку можно выполнить и с помощью обхода в глубину, отсортировав при этом вершины по времени выхода. Алгоритм при этом похож на поиск цикла в графе.

- Из каждой вершины проводится поиск в глубину.

- При входе вершина красится в серый цвет, при выходе - в чёрный. Если вошли в серую вершину, в алгоритме цикл и сортировка невозможна.

**Алгоритм Борувки** - алгоритм _поиска минимального остовного дерева_ во взвешенном неориентированном связном графе.

1. Изначально каждая вершина графа $G$ — тривиальное дерево, а ребра не принадлежат никакому дереву.

2. Для каждого дерева $T$ найдём минимальное инцидентое ему ребро, добавим к остовному дереву все такие рёбра.

3. Повторить шаг 2, пока в графе не останется одно дерево $T$.

**Жадный алгоритм** - на каждом шаге делается лучшая для данного момента операция.

**Алгоритм “ближайшего соседа”** (Ярник, Прим, Дейкстра) - поиск остновного дерева минимальной стоимости.

На вход алгоритма подаётся связный неориентированный граф. Для каждого ребра задаётся его стоимость.
Сначала берётся произвольная вершина и находится ребро, инцидентное данной вершине и обладающее наименьшей стоимостью. Найденное ребро и соединяемые им две вершины образуют дерево. Затем, рассматриваются рёбра графа, один конец которых — уже принадлежащая дереву вершина, а другой — нет; из этих рёбер выбирается ребро наименьшей стоимости. Выбираемое на каждом шаге ребро присоединяется к дереву. Рост дерева происходит до тех пор, пока не будут исчерпаны все вершины исходного графа.

**Алгоритм Дейкстры** находит _кратчайший путь от одной из вершин графа_ до всех остальных. Алгоритм работает только для графов _без рёбер отрицательного веса_.

1. Каждый раз, когда мы хотим посетить новый узел, мы выберем узел с наименьшим известным расстоянием.

2. Как только мы переместились в узел, мы проверяем каждый из соседних узлов. Мы вычисляем расстояние от соседних узлов до корневых узлов, суммируя стоимость ребер, которые ведут к этому новому узлу.

3. Если расстояние до узла меньше известного расстояния, мы обновим самое короткое расстояние.

На каждом шаге существует множество уже обработанных вершин и еще не обработанных.

**Алгоритм Форда-Беллмана** - в отличие от алгоритма Дейкстры, способен корректно обработать отрицательный вес. За время $O(|V| \cdot |E|)$  алгоритм находит кратчайшие пути от одной вершины графа до всех остальных.

**Алгоритм A*** - эвристический алгоритм поиска.

**Алгоритм Флойда-Уоршелла** — алгоритм для нахождения _кратчайших расстояний между всеми вершинами взвешенного графа без циклов с отрицательными весами_ с использованием метода динамического программирования.

Алгоритм работает за $O(n^3)$ времени и использует $O(n^2)$ памяти.
 
**Алгоритм Форда-Фалкерсона** решает задачу нахождения максимального потока в транспортной сети.

**Алгоритм Каргера-Штейна** - вероятностный алгоритм, позволяющий найти *минимальный разрез связного графа*.
