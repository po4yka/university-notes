Алгоритм Рабина-Карпа

# Алгоритм Рабина-Карпа

## Постановка задачи

Есть текст длиной $n$, есть шаблон длиной $m$.

$q$ − число вхождений, $p$ − простое число.

_Нужно найти все вхождения шаблона в текст._

Наивный алгоритм сравнивает посимвольно символы начиная с первого. Если закончился шаблон или получено несовпадение, алгоритм сдвигается на 1.

Посимвольное сравнение не очень эффективно. Строке нужно сопоставить число, которое бы характеризовало её уникальным образом - например, с помощью хэш-функции.

В таком случае, нужно посчитать хэш-функцию для шаблона и для первых m символов текста. Если хэш-сумма не совпадает, то строки точно не совпадают. Если же совпадают, тогда нужно выполнить посимвольную проверку. Вычисление хэш-функции для шаблона - $O(m)$. Проблема в том, что в худшем случае данный алгоритм работает даже хуже, чем наивный алгоритм.

## Хэширование

Допустим, стоит задача написать телефонную книжку. На вход поступает 10-значный номер, нужно сказать, кому принадлежит номер.

1. Если номер преобразуется в индекс, то задачу можно решить очень быстро, но длина массива в таком случае - $10^{10}$.

2. Можно хранить только те номера, которые нужны - например, в списке. В этом случае поиск по книжке (и другие операции тоже) будет равен количеству номеров. Это эффективно по памяти, но не по производительности.

Выделяем массив длины $m$ - пусть будет не более 100 номеров. Нужно взять хэш-функцию, которая сопоставит номеру число от 0 до 100. Пример - деление по модулю. Проблема в том, что для очень большого количества объектов произойдут коллизии - совпадение хэш-функций для разных объектов. Разрешить коллизии можно разными способами:

1. Сделать массив из списков. Каждый элемент будет содержать объекты, содержащие одинаковые хэш-суммы.

    В худшем случае сложность - максимальная длина списка.

2. Переход в первую незанятую ячейку.

3. Открытая адресация - под одинаковые хэш-суммы может быть выделено несколько позиций.

$$
\varphi: X \to \mathbb{Z}_m - \text{ хэш-функция}
$$

Таким образом, к хэш-функции предъявляются следующие требования:

- Простота расчёта.

- Минимальное количество коллизий:

$$
\forall x, y \in X, x \ne y: P ( \varphi (x) = \varphi (y) ) \le \frac{1}{m}
$$

- Детерминированность - одинаковые значения для одного объекта.

В хэш-функции обычно используется элемент рандомизации - база для хэша берется случайной.

## Полиномиальный хеш для строк

При хэшировании строки необходимо учитывать не только разные символы, но и разные позиции символов.

$$
\varphi(0 \dots n - 1) = \sum\limits_{i = 0}^{n - 1} p^i s[i] ~ mod ~ r
$$

$p \in [1 \dots r - 1]$ - простое число.

Модуль необходим, чтобы решить проблему переполнения.

Для работы алгоритма нужно считать хеш подстроки. Далее операции в кольце вычетов по модулю $r$.

$$
\varphi (0 \dots j) = \sum\limits_{i = 0}^{j} p^i s[i] = s[0] + p s[1] + \dots + 
$$
$$ + p^{i - 1} s[i - 1] + p^i s[i] + \dots p^{j - 1} s[j - 1] + p^j s[j] =
$$

$$
= ( s[0] + p s[1] + \dots + p^{i - 1} s[i - 1] ) + 
$$
$$ + (p^i s[i] + \dots + p^{j - 1} s[j - 1] + p^j s[j]) =
$$

$$
= ( s[0] + ps[1] + \dots p^{i - 1} s[i - 1] ) + p^i ( s[i] + \dots + 
$$
$$+ p^{(j - i - 1)} s[j - 1] + p^{j - i} s[j] ) =
$$

$$
= \varphi (0 \dots i - 1) + p^i \varphi (i \dots j)
$$

Отсюда

$$
\varphi (i \dots j) = \left( \frac{1}{p^i} \right) ( \varphi (0 \dots i - 1) )
$$

Вероятность коллизии такого хеша:

$$
P ( \varphi (s_1) = \varphi (s_2) ) = \frac{\max ( |S_1|, |S_2| )}{P} = \frac{L}{P}
$$

Если $p \gg mL$, то будет $O \left( \frac{1}{m} \right)$.

Вычислять многочлен эффективнее по схеме Горнера, чем с помощью прямого умножения. Время вычисления будет пропорционально длине строки.

### Алгоритм для быстрого вычисления хешей

Время работы в таком случае всё равно будет пропорционально $n^2$, и выигрыша не будет. Чтобы всё же обеспечить выигрыш во времени, нужно найти зависимость между соседними хэшами. Если хэш считается как сумма, это просто: вычесть слагаемое для первого символа, домножить на $x$ и прибавить слагаемое для последнего.

$$
\varphi (i + 1 \dots i + m + 1) = \varphi (i \dots i + m - 1) - p^{m-1} s[i]
$$

$$
\varphi ( i + 1 \dots i + m ) = p \cdot \varphi ( i + 1 \dots i + m - 1 ) + s[i + m]
$$

Результат:

$$
\varphi ( i + 1 \dots i + m ) = p \cdot \varphi (i \dots i + m - 1) - p^m s[i] + s[i + m]
$$

## Алгоритм Рабина-Карпа

Пусть текст - $s$, шаблон - $a, n = |s|, m = |a|$.

Алгоритм начинается с подсчёта $\varphi (s[0 \dots m - 1])$ и $\varphi ( a [0 \dots m - 1] )$.

Для $i \in [0 \dots n - m]$ вычисляется $\varphi ( s[i \dots i + m - 1] )$. Если он оказывается равным хешу образца, то нужно явно сравнить строки.

Псевдокод
```
vector<int> rabinKarp (s : string, w : string):
   vector<int> answer
   int n = s.length
   int m = w.length
   int hashS = hash(s[0..m - 1])
   int hashW = hash(w[0..m - 1])
   for i = 0 to n - m
        if hashS == hashW
             answer.add(i)
        hashS = (p * hashS - pm * hash(s[i]) + hash(s[i + m])) mod r 
        // r — некоторое большое число, p — некоторое простое число
   return answer

```